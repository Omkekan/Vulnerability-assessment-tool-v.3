import pandas as pd
import nmap
import joblib
import requests
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score
import tkinter as tk
from tkinter import Button, Label, Entry, scrolledtext, messagebox
import threading
import webbrowser

# Load the vulnerability dataset
df = pd.read_csv('cve.csv')

# Preprocess the dataset
df['access_complexity'].fillna('NONE', inplace=True)
df['access_vector'].fillna('NONE', inplace=True)
df['impact_availability'].fillna('NONE', inplace=True)
df['impact_confidentiality'].fillna('NONE', inplace=True)
df['impact_integrity'].fillna('NONE', inplace=True)

df['access_complexity'] = df['access_complexity'].replace({'LOW': 1, 'MEDIUM': 2, 'HIGH': 3, 'NONE': 0})
df['access_vector'] = df['access_vector'].replace({'NETWORK': 1, 'ADJACENT_NETWORK': 2, 'LOCAL': 3, 'NONE': 0})
df['impact_availability'] = df['impact_availability'].replace({'NONE': 0, 'PARTIAL': 1, 'COMPLETE': 2})
df['impact_confidentiality'] = df['impact_confidentiality'].replace({'NONE': 0, 'PARTIAL': 1, 'COMPLETE': 2})
df['impact_integrity'] = df['impact_integrity'].replace({'NONE': 0, 'PARTIAL': 1, 'COMPLETE': 2})
df['impact_total'] = df['impact_availability'] + df['impact_confidentiality'] + df['impact_integrity']

# Define features and target
features = ['cvss', 'impact_total', 'access_complexity', 'access_vector']
X = df[features]
y = df['cwe_code']

# Split the dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Scale features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Train a model
model = RandomForestClassifier(random_state=42)
model.fit(X_train_scaled, y_train)

# Save the model for later use
joblib.dump(model, 'vuln_model.pkl')

# Evaluate model performance
y_pred = model.predict(X_test_scaled)
print("Model Accuracy:", accuracy_score(y_test, y_pred))

# Function to perform Nmap scan and return vulnerabilities
def run_nmap_scan(target_ip):
    # Initialize the scanner
    scanner = nmap.PortScanner()
    
    # Perform a scan with OS detection (-O) and service version detection (-sV)
    scan_results = scanner.scan(target_ip, arguments='-sV -O')

    # Print the raw scan results for debugging
    print("Raw scan results:", scan_results)  # Debugging line to inspect scan results

    vulnerabilities = []

    # Iterate through each host in the scan results
    for host in scan_results['scan']:
        print(f"Host: {host}")

        # Check if OS detection information is available
        if 'osmatch' in scan_results['scan'][host]:
            os_info = scan_results['scan'][host]['osmatch'][0] if scan_results['scan'][host]['osmatch'] else {}
            os_name = os_info.get('name', 'Unknown OS')
            os_accuracy = os_info.get('accuracy', 'Unknown Accuracy')
            log_text.insert(tk.END, f"Detected OS: {os_name} (Accuracy: {os_accuracy}%)\n")
        else:
            log_text.insert(tk.END, "OS detection not available for this host.\n")

        # Check for protocols and iterate through them
        for proto in scan_results['scan'][host]:
            if proto in ['tcp', 'udp']:  # We're only interested in TCP/UDP protocols
                print(f"Checking protocol: {proto}")
                
                # Iterate through each port in the protocol results
                for port in scan_results['scan'][host][proto]:
                    # Get port information; this should be a dict
                    port_info = scan_results['scan'][host][proto][port]
                    
                    # Check if port_info is a dictionary
                    if isinstance(port_info, dict):
                        service = port_info.get('name', 'Unknown')  # Service name (e.g., http, ftp)
                        version = port_info.get('version', 'Unknown')  # Service version
                        
                        # Log the service and version information
                        print(f"Port: {port}, Service: {service}, Version: {version}")
                        
                        # Search for vulnerabilities related to the service and version
                        vulnerability_info = search_vulnerability(service, version)
                        vulnerabilities.append({
                            'port': port,
                            'service': service,
                            'version': version,
                            'vulnerabilities': vulnerability_info
                        })
                    else:
                        print(f"Warning: Port info for port {port} is not a dictionary. Found: {port_info}")
            else:
                print(f"Warning: Protocol '{proto}' does not contain valid port data.")
    
    return vulnerabilities



# Function to search for vulnerability online (Google API)
def search_vulnerability(service_name, version):
    GOOGLE_API_KEY = "YOUR_API_KEY"
    SEARCH_ENGINE_ID = "YOUR_SEARCH_ENGINE_ID"
    query = f"{service_name} {version} vulnerability"
    url = f"https://www.googleapis.com/customsearch/v1?key={GOOGLE_API_KEY}&cx={SEARCH_ENGINE_ID}&q={query}"

    try:
        response = requests.get(url)
        if response.status_code == 200:
            items = response.json().get('items', [])
            results = "\n".join([f"{item['title']}: {item['link']}" for item in items])
            return results if results else "No vulnerabilities found."
        else:
            return f"Error: {response.status_code}"
    except Exception as e:
        return f"Error while searching vulnerabilities: {e}"

# Define the start_scan function
def start_scan():
    target_ip = target_entry.get()
    if not target_ip:
        messagebox.showerror("Input Error", "Please enter a valid target IP or hostname.")
        return

    scan_button.config(state=tk.DISABLED)
    log_text.insert(tk.END, f"[*] Starting scan on {target_ip}...\n")

    def run_scan_thread():
        try:
            vulnerabilities = run_nmap_scan(target_ip)
            log_text.insert(tk.END, "[*] Scan completed. Analyzing results...\n")

            if not vulnerabilities:
                log_text.insert(tk.END, "[!] No vulnerabilities found.\n")
                return

            for vuln in vulnerabilities:
                port = vuln['port']
                service = vuln['service']
                version = vuln['version']
                vuln_info = vuln['vulnerabilities']
                log_text.insert(tk.END, f"Port: {port}, Service: {service}, Version: {version}\n")
                log_text.insert(tk.END, f"Vulnerabilities for {service} {version}:\n{vuln_info}\n")

            log_text.insert(tk.END, "[*] Scan finished.\n")
        except Exception as e:
            log_text.insert(tk.END, f"[!] Error during scan: {e}\n")
        finally:
            scan_button.config(state=tk.NORMAL)

    scan_thread = threading.Thread(target=run_scan_thread)
    scan_thread.start()

# Main GUI and Scan Functionality
app = tk.Tk()
app.title("AI-Enhanced Vulnerability Scanner")

Label(app, text="Target IP:").grid(row=0, column=0)
target_entry = Entry(app)
target_entry.grid(row=0, column=1)

scan_button = Button(app, text="Start Scan", command=start_scan)
scan_button.grid(row=1, column=0)

log_text = scrolledtext.ScrolledText(app, width=80, height=20)
log_text.grid(row=2, column=0, columnspan=2)

app.mainloop()
